<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Group 1">
<meta name="dcterms.date" content="2023-11-27">

<title>Finding Emergency Sanitary Pad Stations in City Corners (寻找城市角落的紧急卫生巾站)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="index_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="index_files/libs/quarto-contrib/bookup_fonts_gwf-0.0/fonts-embed.css" rel="stylesheet">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#interactive-plot" id="toc-interactive-plot" class="nav-link active" data-scroll-target="#interactive-plot">Interactive plot</a>
  <ul class="collapse">
  <li><a href="#interactive-plot-presentation" id="toc-interactive-plot-presentation" class="nav-link" data-scroll-target="#interactive-plot-presentation">Interactive plot Presentation</a></li>
  <li><a href="#methodology-of-interactive-plot-creation" id="toc-methodology-of-interactive-plot-creation" class="nav-link" data-scroll-target="#methodology-of-interactive-plot-creation">Methodology of Interactive Plot Creation</a>
  <ul class="collapse">
  <li><a href="#data-collection-and-preparation" id="toc-data-collection-and-preparation" class="nav-link" data-scroll-target="#data-collection-and-preparation">Data Collection and Preparation</a></li>
  <li><a href="#data-transformation" id="toc-data-transformation" class="nav-link" data-scroll-target="#data-transformation">Data Transformation</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding Emergency Sanitary Pad Stations in City Corners (寻找城市角落的紧急卫生巾站)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Group 1 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 27, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<style>
/* Base styles for sidebar */
#sidebarleft {
  position: fixed;
  top: 0;
  left: 0;
  width: 25%; /* Use percentage for responsive sizing */
  height: 100vh;
  background-color: grey;
  background-image: url('girl.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  z-index: 1000;
}

/* Ensure that content does not overlap with the sidebar */
#quarto-content {
  margin-left: calc(20% + 1rem); /* Use calc to dynamically calculate margin */
}

/* Adjust sidebar and content on smaller screens */
@media (max-width: 1024px) {
  #sidebarleft {
    width: 20%;
  }
  #quarto-content {
    margin-left: calc(20% + 1rem);
  }
}

@media (max-width: 768px) {
  #sidebarleft {
    width: 25%;
  }
  #quarto-content {
    margin-left: calc(25% + 1rem);
  }
  
}

@media (max-width: 480px) {
  #sidebarleft {
    width: 35%;
  }
  #quarto-content {
    margin-left: calc(35% + 1rem);
  }
}

.sidebar.toc-left, .sidebar.margin-sidebar {
  position: fixed;
  top: 0;
  right: 0;
  width: 10vw;
  max-width: 300px;
  height: 100vh;
  overflow-y: auto;
  z-index: 1050;
}

.content {
  margin-right: 1rem; /* Add some space on the right */
}

/* Additional styles to ensure no overlap */
#quarto-content.page-columns #quarto-margin-sidebar, #quarto-content.page-columns #quarto-sidebar {
    grid-column-start: 3;
}

.sidebar.toc-left, .sidebar.margin-sidebar {
  margin-left: 26px; /* Adjust if necessary */
}
  
iframe {
    margin-bottom: -90px; /* Reduces the bottom margin of the iframe */
}

</style>
<div id="sidebarleft">

</div>
<section id="contents" class="level11">
<p class="heading">Contents</p>
</section>
<section id="interactive-plot" class="level1">
<h1>Interactive plot</h1>
<section id="interactive-plot-presentation" class="level2">
<h2 class="anchored" data-anchor-id="interactive-plot-presentation">Interactive plot Presentation</h2>
<iframe src="plot.html" width="100%" height="400">
</iframe>
</section>
<section id="methodology-of-interactive-plot-creation" class="level2">
<h2 class="anchored" data-anchor-id="methodology-of-interactive-plot-creation">Methodology of Interactive Plot Creation</h2>
<section id="data-collection-and-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-collection-and-preparation">Data Collection and Preparation</h3>
<p>Our study utilized a collected dataset detailing the locations of Emergency Sanitary Pad Stations across various city corners. This dataset included key variables such as the type of location (e.g., shopping malls, universities), the district in which the station is located, the number of available stations, and the distance to the nearest metro station. To facilitate our analysis, we converted these data points into geographical coordinates.</p>
</section>
<section id="data-transformation" class="level3">
<h3 class="anchored" data-anchor-id="data-transformation">Data Transformation</h3>
<p>In order to address data inconsistencies and enhance the visualization, we undertook several preprocessing steps: - <strong>Handling Missing Values:</strong> Instances where the number of stations was not reported (<code>NA</code> values) were set to zero. This approach ensures continuity and completeness in our analysis. - <strong>Normalization:</strong> Considering the high variance observed in the number of stations across different locations, we applied a logarithmic normalization. This transformation not only stabilized the variance but also improved the interpretability of our data in the visual representation.</p>
<section id="interactive-map-and-scatter-plot-creation" class="level4">
<h4 class="anchored" data-anchor-id="interactive-map-and-scatter-plot-creation">Interactive Map and Scatter Plot Creation</h4>
<p>We employed ECharts, a powerful, interactive charting and visualization library, for creating our visualizations. The methodology for developing these interactive plots is described below:</p>
<ol type="1">
<li><strong>Initializing the Containers:</strong>
<ul>
<li>The interactive map and scatter plot are displayed in separate containers (<code>mapContainer</code> and <code>scatterContainer</code>) within the webpage. These containers are dynamically sized and aligned for optimal viewing.</li>
</ul></li>
<li><strong>Loading and Parsing Data:</strong>
<ul>
<li>Using jQuery, we loaded our dataset from a JSON file. The data was then parsed to create a structured representation, where each station’s location was associated with its respective data points such as distance to the metro, quantity, and type.</li>
</ul></li>
<li><strong>Chart Initialization and Configuration:</strong>
<ul>
<li>Two ECharts instances were created for the map (<code>mapChart</code>) and the scatter plot (<code>scatterChart</code>).</li>
<li>The map visualization utilized a GeoJSON of the relevant city areas to plot the station locations.</li>
<li>The scatter plot was designed to display the log-normalized number of stations and their distance to the nearest metro station. Different types of locations were color-coded for better differentiation.</li>
</ul></li>
<li><strong>Data Grouping and Representation:</strong>
<ul>
<li>The data was grouped by location type to facilitate comparative analysis across different categories.</li>
<li>Each group’s data was represented as a series in the scatter plot, with individual data points reflecting the number of stations and their metro proximity.</li>
</ul></li>
<li><strong>Interactivity and Responsiveness:</strong>
<ul>
<li>Click events on the map trigger updates in the scatter plot, showing data corresponding to the selected area.</li>
<li>The scatter plot dynamically adjusts its display based on the selected map region, providing an interactive experience that allows users to explore data in specific city areas.</li>
</ul></li>
<li><strong>Styling and Customization:</strong>
<ul>
<li>We customized the styling of the map and scatter plot for clarity and ease of use. This included adjustments to the layout, color schemes, labels, and tooltips to enhance user interaction and data comprehension.</li>
</ul></li>
</ol>
<p>Through these methodological steps, we successfully developed an interactive visualization tool that enables users to explore the distribution and characteristics of Emergency Sanitary Pad Stations across different city areas. This tool not only presents the data in an engaging and informative manner but also allows for an in-depth analysis of the availability and accessibility of these crucial facilities.</p>
<!--  


# Introduction
## Background and Purpose
Introduce the necessity of emergency sanitary pad stations in urban areas, referencing the importance of accessibility and public health.

## Scope of the Study
Define the geographical and demographic scope of your research. （可提及主要的两个部分，一个是可视化，一个是小程序那里under development的那个设备，太阳能那个，提第二点时提我们有算一些东西）

# Methodology

## Data Collection
Outline the methods used to gather data on sanitary pad dispensers, including any surveys, field studies, or database analyses.

## Interactive Plot Explanation
Describe how the interactive plot was developed and how it visualizes the data.

# Analysis of Current Situation
## Distribution of Dispensers
Present findings on the number and locations of sanitary pad dispensers across different districts.

## Accessibility and Visibility
Assess how accessible and visible these stations are to the public.

# Comparative Study
## Benchmarking
Compare the availability of sanitary pad dispensers in your study area with other cities or standards, if applicable.

## Lessons from Previous Studies
Reference the "育婴室" (baby care rooms) study as a benchmark or point of comparison.

# Interactive Plot Section
## Data Visualization
Present the interactive plot showing the distribution of sanitary pad dispensers.

## Interpretation of Data


::: {.cell}

```{.r .cell-code}
# Load necessary libraries
library(dplyr)
```

::: {.cell-output .cell-output-stderr}
```

Attaching package: 'dplyr'
```
:::

::: {.cell-output .cell-output-stderr}
```
The following objects are masked from 'package:stats':

    filter, lag
```
:::

::: {.cell-output .cell-output-stderr}
```
The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union
```
:::

```{.r .cell-code}
library(scales)

# Create data frame
data <- data.frame(
  quantity = c(3, 1, 17, 10, NA, 18, 7, NA, 28, 4, 17, 9, 5, 23, 7, 5, 3, 6, NA, NA, 6, NA, NA, 35, 6, 3, 6, 5, NA),
  distance_to_metro = c(126, 159, 274, 814, 1700, 574, 110, 109, 435, 473, 1300, 1200, 1600, 1500, 1000, 1200, 697, 798, 1000, 767, 876, 766, 488, 2000, 1200, 3000, 386, 273, 860),
  score = 1:29
)

# Min-Max Normalization
df_minmax <- as.data.frame(lapply(data, function(x) ifelse(is.na(x), NA, rescale(x))))

# Standardization (Z-score normalization)
df_standardized <- as.data.frame(scale(data))

# Log Transformation - Handling NA values
df_log <- data
df_log$quantity <- ifelse(is.na(df_log$quantity), NA, log(df_log$quantity + 1))
df_log$distance_to_metro <- ifelse(is.na(df_log$distance_to_metro), NA, log(df_log$distance_to_metro + 1))


library(openxlsx)

# Create a new workbook
wb <- createWorkbook()

# Add sheets and write data to each sheet
addWorksheet(wb, "Min-Max Normalization")
writeData(wb, sheet = "Min-Max Normalization", df_minmax)

addWorksheet(wb, "Standardization")
writeData(wb, sheet = "Standardization", df_standardized)

addWorksheet(wb, "Log Transformation")
writeData(wb, sheet = "Log Transformation", df_log)

# Save the workbook as an Excel file
saveWorkbook(wb, "NormalizedData.xlsx", overwrite = TRUE)
```
:::




Provide insights and trends identified from the interactive plot.






# Challenges and Limitations
## Identify Challenges
Discuss any challenges faced in locating and assessing the sanitary pad stations.

## Study Limitations
Address any limitations of your research methods or data.

# Recommendations and Future Work
## Improving Accessibility
Suggest ways to increase the accessibility and number of sanitary pad stations.

## Policy Recommendations
Propose policy or public health recommendations based on your findings.

# Conclusion
## Summary of Findings
Concisely recap the key findings and insights from your study.

## Closing Remarks
Reflect on the importance of sanitary pad accessibility in urban areas.

# References
List of Sources: Include all the references and data sources used in your study.

-->
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>